= Pinject =

Pinject is a dependency injection framework for python.

The primary goal of Pinject is to help you assemble objects into graphs in
an easy, maintainable way.

== Overview ==

If you are already familiar with dependency injection frameworks such as
Guice, this section gives you a high level overview of Pinject and how it
might be similar to or different than other dependency injection frameworks.

  * Pinject uses code and decorators to configure injection, not a separate config file.
  * Bindings are keyed by arg name, (not class type, since Python is dynamically typed).
  * Pinject automatically creates bindings to `some_class` arg names for `SomeClass` classes.
  * You can ask Pinject only to create bindings from binding specs and classes whose `__init__()` is marked with `@inject`.
  * A binding spec is a class that creates explicit bindings.
  * A binding spec can bind arg names to classes or to instances.
  * A binding spec can bind arg names `foo` to provider methods `provide_foo()`.
  * Binding specs can depend on (i.e., include) other binding specs.
  * You can annotate args and bindings to distinguish among args/bindings for the same arg name.
  * Pinject has two built-in scopes: "singleton" (always memoized; the default) and "prototype" (never memoized).
  * You can define custom scopes, and you can configure which scopes are accessible from which other scopes.
  * Pinject doesn't allow injecting `None` by default, but you can turn off that check.

== Basic dependency injection ==

The most important function in the `pinject` module is `new_object_graph()`.
This creates an `ObjectGraph`, which you can use to instantiate objects using
dependency injection.  If you pass no args to `new_object_graph()`, it will
return a reasonably configured default `ObjectGraph`.

{{{
>>> class OuterClass(object):
...     def __init__(self, inner_class):
...         self.inner_class = inner_class
...
>>> class InnerClass(object):
...     def __init__(self):
...         self.forty_two = 42
...
>>> obj_graph = pinject.new_object_graph()
>>> outer_class = obj_graph.provide(OuterClass)
>>> outer_class.inner_class.forty_two
42
>>>
}}}

As you can see, you don't need to tell Pinject how to construct its
`ObjectGraph`, and you don't even need to put decorators in your code.
Pinject has reasonable defaults that allow it to work out of the box.

A Pinject _binding_ is an association between an _arg name_ and a _provider_.
In the example above, Pinject created a binding between the arg name
`inner_class` and an implicitly created provider for the class `InnerClass`.
The binding it had created was how Pinject knew that it should pass an
instance of `InnerClass` as the value of the `inner_class` arg when
instantiating `OuterClass`.

== Implicit class bindings ==

Pinject creates implicit bindings for classes.  The implicit bindings assume
your code follows PEP8 conventions: your classes are named in `CamelCase`, and
your args are named in `lower_with_underscores`.  Pinject transforms class
names to injectable arg names by lowercasing words and connecting them with
underscores.  It will also ignore any leading underscore on the class name.

|| Class name || Arg name  ||
|| `Foo`      || `foo`     ||
|| `FooBar`   || `foo_bar` ||
|| '_Foo'     || `foo`     ||
|| `_FooBar`  || `foo_bar` ||

If two classes map to the same arg name, whether those classes are in the same
module or different modules, Pinject will not create an implicit binding for
that arg name (though it will not raise an error).

`new_object_graph()` takes a `get_arg_names_from_class_name` arg.  This is a
function that takes in a class name (e.g., `FooBar`) and returns the arg names
to which that class should be implicitly bound (e.g., `foo_bar`).  It has the
behavior above by default but can be overridden.

{{{
>>> class OuterClass(object):
...     def __init__(self, my_InnerClass):
...         self.my_InnerClass = my_InnerClass
...
>>> class InnerClass(object):
...     def __init__(self):
...         self.forty_two = 42
...
>>> def custom_get_arg_names(class_name):
...     return ['my_' + class_name]
...
>>> obj_graph = pinject.new_object_graph(
...     get_arg_names_from_class_name=custom_get_arg_names)
>>> outer_class = obj_graph.provide(OuterClass)
>>> outer_class.my_InnerClass.forty_two
42
>>>
}}}

The function passed as the `get_arg_names_from_class_name` arg can return as
many or as few arg names as it wants.  If it always returns the empty list
(i.e., if it is `lambda _: []`), then that disables implicit class bindings.

== Finding classes and providers for implicit bindings ==

So far, the examples have not told `new_object_graph()` the classes for which
it should create implicit bindings.  `new_object_graph()` by default looks in
all imported modules, but you may sometimes want to restrict the classes for
which `new_object_graph()` creates implicit bindings.  `new_object_graph()`
has two args for this purpose.

  * The `modules` arg specifies in which (python) modules to look for classes; this defaults to `ALL_IMPORTED_MODULES`.
  * The `classes` arg specifies a exact list of classes; this defaults to `None`.

{{{
>>> class SomeClass(object):
...     def __init__(self, foo):
...         self.foo = foo
...
>>> class Foo(object):
...     pass
...
>>> obj_graph = pinject.new_object_graph(modules=None, classes=[SomeClass])
>>> # obj_graph.provide(SomeClass)  # would raise a NothingInjectableForArgError
>>> obj_graph = pinject.new_object_graph(modules=None, classes=[SomeClass, Foo])
>>> some_class = obj_graph.provide(SomeClass)
>>>
}}}

== Binding specs ==

To create any bindings more complex than the implicit class bindings described
above, you use a _binding spec_.  A binding spec is any python class that
inherits from `BindingSpec`.  A binding spec can do three things:

  * Its `configure()` method can create explicit bindings to classes or instances.
  * Its `dependencies()` method can return depended-on binding specs.
  * It can have provider methods, for which explicit bindings are created.

The `new_object_graph()` function takes a sequence of binding spec instances
as its `binding_specs` arg.  `new_object_graph()` takes binding spec
instances, rather than binding spec classes, so that you can manually inject
any initial dependencies into the binding specs as needed.

Binding specs should generally live in files named `binding_specs.py`, where
each file is named in the plural even if there is exactly one binding spec in
it.  Ideally, a directory's worth of functionality should be coverable with a
single binding spec.  If not, you can create multiple binding specs in the
same `binding_specs.py` file.  If you have so many binding specs that you need
to split them into multiple files, you should name them each with a
`_binding_specs.py` suffix.

=== Binding spec `configure()` methods ===

Pinject creates implicit bindings for classes, but sometimes the implicit
bindings aren't what you want.  For instance, if you have
`SomeReallyLongClassName`, you may not want to name your initializer args
`some_really_long_class_name` but instead use something shorter like
`long_name`, just for this class.

For such situations, you can create explicit bindings using the `configure()`
method of a binding spec.  The `configure()` method takes a function `bind()`
as an arg and calls that function to create explicit bindings.

{{{
>>> class SomeClass(object):
...     def __init__(self, long_name):
...         self.long_name = long_name
...
>>> class SomeReallyLongClassName(object):
...     def __init__(self):
...         self.foo = 'foo'
...
>>> class MyBindingSpec(pinject.BindingSpec):
...     def configure(self, bind):
...         bind('long_name', to_class=SomeReallyLongClassName)
...
>>> obj_graph = pinject.new_object_graph(binding_specs=[MyBindingSpec()])
>>> some_class = obj_graph.provide(SomeClass)
>>> some_class.long_name.foo
'foo'
>>>
}}}

The `bind()` function passed to a binding function binds its first arg, which
must be an arg name (as a `str`), to exactly one of two kinds of things.

  * Using `to_class` binds to a class.  When the binding is used, Pinject injects an instance of the class.
  * Using `to_instance` binds to an instance of some object.  Every time the binding is used, Pinject uses that instance.

{{{
>>> class SomeClass(object):
...     def __init__(self, foo):
...         self.foo = foo
...
>>> class MyBindingSpec(pinject.BindingSpec):
...     def configure(self, bind):
...         bind('foo', to_instance='a-foo')
...
>>> obj_graph = pinject.new_object_graph(binding_specs=[MyBindingSpec()])
>>> some_class = obj_graph.provide(SomeClass)
>>> some_class.foo
'a-foo'
>>>
}}}

=== Binding spec dependencies ===

Binding specs can declare dependencies.  A binding spec declares its
dependencies by returning a sequence of instances of the dependent binding
specs from its `dependencies()` method.

{{{
>>> class SomeClass(object):
...     def __init__(self, foo, bar):
...         self.foobar = foo + bar
...
>>> class BindingSpecOne(pinject.BindingSpec):
...     def configure(self, bind):
...         bind('foo', to_instance='foo-')
...
>>> class BindingSpecTwo(pinject.BindingSpec):
...     def configure(self, bind):
...         bind('bar', to_instance='-bar')
...     def dependencies(self):
...         return [BindingSpecOne()]
...
>>> obj_graph = pinject.new_object_graph(binding_specs=[BindingSpecTwo()])
>>> some_class = obj_graph.provide(SomeClass)
>>> some_class.foobar
'foo--bar'
>>>
}}}

If classes from module A are injected as collaborators into classes from
module B, then you should consider having the binding spec for module B depend
on the binding spec for module A.  In this way, you can build a graph of
binding spec dependencies that mirrors the graph of collaborator dependencies.

Since explicit bindings cannot conflict (see the section below on binding
precedence), a binding spec should only have dependencies that there will
never be a choice about using.  If there may be a choice, then it is better to
list the binding specs separately and explicitly when calling
`new_object_graph()`.

=== Provider methods ===

If it takes more to instantiate a class than calling its initializer and
injecting initializer args, then you can write a _provider method_ for it.
Pinject can use provider methods to instantiate objects used to inject as the
values of other args.

Pinject looks on binding specs for methods named like provider methods and
then creates explicit bindings for them.

{{{
>>> class SomeClass(object):
...     def __init__(self, foo):
...         self.foo = foo
...
>>> class SomeBindingSpec(pinject.BindingSpec):
...     def provide_foo(self):
...         return 'some-complex-foo'
...
>>> obj_graph = pinject.new_object_graph(binding_specs=[SomeBindingSpec()])
>>> some_class = obj_graph.provide(SomeClass)
>>> some_class.foo
'some-complex-foo'
>>>
}}}

By default, Pinject looks for methods whose names start with `provide_`, and
it assumes that the methods are providers for whatever the rest of their
method names are.  For instance, Pinject assumes that the method
`provide_foo_bar()` is a provider method for the arg name `foo_bar`.

You can override this default behavior by passing an arg named
`get_arg_names_from_provider_fn_name` to `new_object_graph()`.

{{{
>>> class SomeClass(object):
...     def __init__(self, foo):
...         self.foo = foo
...
>>> class SomeBindingSpec(pinject.BindingSpec):
...     def gimme_some_foo(self):
...         return 'some-foo'
...
>>> def custom_get_arg_names(provider_fn_name):
...     if provider_fn_name.startswith('gimme_some_'):
...         return [provider_fn_name[len('gimme_some_'):]]
...     else:
...         return []
...
>>> obj_graph = pinject.new_object_graph(
...     binding_specs=[SomeBindingSpec()],
...     get_arg_names_from_provider_fn_name=custom_get_arg_names)
>>> some_class = obj_graph.provide(SomeClass)
>>> some_class.foo
'some-foo'
>>>
}}}

A function passed as the `get_arg_names_from_provider_fn_name` arg to
`new_object_graph()` takes the name of a potential provider method and returns
the arg names for which that provider method is a provider (and an empty list
if it does not seem to name a provider method).

Pinject injects all args of provider methods that have no default when it
calls the provider method.

{{{
>>> class SomeClass(object):
...     def __init__(self, foobar):
...         self.foobar = foobar
...
>>> class SomeBindingSpec(pinject.BindingSpec):
...     def provide_foobar(self, bar, hyphen='-'):
...         return 'foo' + hyphen + bar
...     def provide_bar(self):
...         return 'bar'
...
>>> obj_graph = pinject.new_object_graph(binding_specs=[SomeBindingSpec()])
>>> some_class = obj_graph.provide(SomeClass)
>>> some_class.foobar
'foo-bar'
>>>
}}}

== Binding precedence ==

Bindings have precedence: explicit bindings take precedence over implicit
bindings.

  * Explicit bindings are the bindings that come from binding specs.
  * Implicit bindings are the bindings created for classes in the `modules` and `classes` args passed to `new_object_graph()`.

Pinject will prefer an explicit to an implicit binding.

{{{
>>> class SomeClass(object):
...     def __init__(self, foo):
...         self.foo = foo
...
>>> class Foo(object):
...     pass
...
>>> class SomeBindingSpec(pinject.BindingSpec):
...     def configure(self, bind):
...         bind('foo', to_instance='foo-instance')
...
>>> obj_graph = pinject.new_object_graph(binding_specs=[SomeBindingSpec()])
>>> some_class = obj_graph.provide(SomeClass)
>>> some_class.foo
'foo-instance'
>>>
}}}

If you have two classes named the same thing, Pinject will have two different
(and thus conflicting) implicit bindings.  But Pinject will not complain
unless you try to use those bindings.  Pinject _will_ complain if you try to
create different (and thus conflicting) explicit bindings.

== Safety ==

Pinject tries to strike a balance between being helpful and being safe.
Sometimes, you may want or need to change this balance.

`new_object_graph()` creates implicit bindings by default.  If you worry that you
may accidentally inject a class or use a provider function unintentionally,
then you can turn off implicit bindings by setting
`only_use_explicit_bindings=True`.  If you do so, then Pinject will only use
explicit bindings.

You can mark a class as explicitly injectable, without having to create a
binding spec for it, by annotating it with `@injectable`.  Classes are also
marked for explicit binding if their initializers are decorated with
`@annotate_arg()` (see below), with or without `@injectable` as well.

{{{
>>> class SomeClass(object):
...     @pinject.injectable
...     def __init__(self, foo):
...         self.foo = foo
...
>>> class SomeBindingSpec(pinject.BindingSpec):
...     def configure(self, bind):
...         bind('foo', to_instance='explicit-foo')
...
>>> obj_graph = pinject.new_object_graph(binding_specs=[SomeBindingSpec()],
...     only_use_explicit_bindings=True)
>>> some_class = obj_graph.provide(SomeClass)
>>> some_class.foo
'explicit-foo'
>>>
}}}

On the opposite side of permissiveness, Pinject by default will complain if a
provider method returns `None`.  If you really want to turn off this default
behavior, you can pass `allow_injecting_none=True` to `new_object_graph()`.

== Annotations ==

Pinject _annotations_ let you have different objects injected for the same arg
name.  For instance, you may have two classes in different parts of your
codebase named the same thing, and you want to use the same arg name in
different parts of your codebase.

On the binding side, an annotation changes the binding so that the key of the
binding includes the annotation object.  When using `bind()` in a binding
spec's `configure()` method, you can pass an `annotated_with` arg to specify
the annotation object.  When defining a provider method, you can use the
`@annotated_with()` decorator to specify the annotation object

On the arg side, an annotation tells Pinject only to inject using a binding
whose binding key includes the annotation object.  You can use
`@annotate_arg()` on an initializer, or on a provider method, to specify the
annotation object.

{{{
>>> class SomeClass(object):
...     @pinject.annotate('foo', 'annot')
...     def __init__(self, foo):
...         self.foo = foo
...
>>> class SomeBindingSpec(pinject.BindingSpec):
...     @pinject.annotated_with('annot')
...     def provide_annot_foo():
...         return 'foo-with-annot'
...     @pinject.annotated_with(12345)
...     def provide_12345_foo():
...         return '12345-foo'
...
>>> obj_graph = pinject.new_object_graph(binding_specs=[SomeBindingSpec()])
>>> some_class = obj_graph.provide(SomeClass)
>>> some_class.foo
'foo-with-annot'
>>>
}}}

You can use any kind of object as an annotation object as long as it
implements `__eq__()` and `__hash__()`.

== Scopes ==

By default, Pinject remembers the object it injected into a (possibly
annotated) arg, so that it can inject the same object into other args with the
same name.  This means that, for each arg name, a single instance of the
bound-to class, or a single instance returned by a provider method, is created
by default.

{{{
>>> class SomeClass(object):
...     def __init__(self, foo):
...         self.foo = foo
...
>>> class SomeBindingSpec(pinject.BindingSpec):
...     def provide_foo(self):
...         return object()
...
>>> obj_graph = pinject.new_object_graph(binding_specs=[SomeBindingSpec()])
>>> some_class_1 = obj_graph.provide(SomeClass)
>>> some_class_2 = obj_graph.provide(SomeClass)
>>> some_class_1.foo is some_class_2.foo
True
>>>
}}}

In some cases, you may want to create new instances, always or sometimes,
instead of reusing them each time they're injected.  If so, you want to use
_scopes_.

A scope controls memoization (i.e., caching).  A scope can choose to cache
never, sometimes, or always.

Pinject has two built-in scopes.  _Singleton scope_ (`SINGLETON`) is the
default and always caches.  _Prototype scope_ (`PROTOTYPE`) is the other
built-in option and does no caching whatsoever.

Every binding is associated with a scope.  You can specify a scope for a
binding by decorating a provider method with `@in_scope()`, or by passing an
`in_scope` arg to `bind()` in a binding spec's `configure()` method.

{{{
>>> class SomeClass(object):
...     def __init__(self, foo):
...         self.foo = foo
...
>>> class SomeBindingSpec(pinject.BindingSpec):
...     @pinject.in_scope(pinject.PROTOTYPE)
...     def provide_foo(self):
...         return object()
...
>>> obj_graph = pinject.new_object_graph(binding_specs=[SomeBindingSpec()])
>>> some_class_1 = obj_graph.provide(SomeClass)
>>> some_class_2 = obj_graph.provide(SomeClass)
>>> some_class_1.foo is some_class_2.foo
False
>>>
}}}

If a binding specifies no scope explicitly, then it is in singleton scope.
Implicit class bindings are always in singleton scope.

Memoization of class bindings works at the class level, not at the binding key
level.  This means that, if you bind two arg names (or the same arg name with
two different annotations) to the same class, and the class is in a memoizing
scope, then the same class instance will be provided when you inject the
different arg names.

{{{
>>> class InjectedClass(object):
...     pass
...
>>> class SomeObject(object):
...     def __init__(self, foo, bar):
...         self.foo = foo
...         self.bar = bar
...
>>> class SomeBindingSpec(binding.BindingSpec):
...     def configure(self, bind):
...         bind('foo', to_class=InjectedClass)
...         bind('bar', to_class=InjectedClass)
...
>>> obj_graph = object_graph.new_object_graph(
...     binding_specs=[SomeBindingSpec()])
>>> some_object = obj_graph.provide(SomeObject)
>>> some_object.foo is some_object.bar
True
>>>
}}}

Pinject memoizes class bindings this way because this is more likely to be
what you mean if you bind two different arg names to the same class in
singleton scope: you want only one instance of the class, even though it may
be injected in multiple places.

== Custom scopes ==

If you want to, you can create your own custom scope.  A custom scope is
useful when you have some objects that need to be reused (i.e., cached) but
whose lifetime is shorter than the entire lifetime of your program.

A custom scope is any class that implements the `Scope` interface.

{{{
class Scope(object):
    def provide(self, binding_key, default_provider_fn):
        raise NotImplementedError()
}}}

The `binding_key` passed to `provide()` will be an object implementing
`__eq__()` and `__hash__()` but otherwise opaque (you shouldn't need to
introspect it).  You can think of the binding key roughly as encapsulating the
arg name and annotation (if any).  The `default_provider_fn` passed to
`provide()` is a zero-arg function that, when called, provides an instance of
whatever should be provided.

The job of a scope's `provide()` function is to return a cached object if
available and appropriate, otherwise to return (and possibly cache) the result
of calling the default provider function.

Scopes almost always have other methods that control clearing the scope's
cache.  For instance, a scope may have "enter scope" and "exit scope" methods,
or a single direct "clear cache" method.  When passing a custom scope to
Pinject, your code should keep a handle to the custom scope and use that
handle to clear the scope's cache at the appropriate time.

You can use one or more custom scopes by passing a map from _scope identifier_
to scope as the `id_to_scope` arg of `new_object_graph()`.

{{{
>>> class MyScope(pinject.Scope):
...     def __init__(self):
...         self._cache = {}
...     def provide(self, binding_key, default_provider_fn):
...         if binding_key not in self._cache:
...             self._cache[binding_key] = default_provider_fn()
...         return self._cache[binding_key]
...     def clear(self):
...         self._cache = {}
...
>>> class SomeClass(object):
...     def __init__(self, foo):
...         self.foo = foo
...
>>> class SomeBindingSpec(pinject.BindingSpec)
...     @pinject.in_scope('my custom scope')
...     def provide_foo():
...         return object()
...
>>> my_scope = MyScope()
>>> obj_graph = pinject.new_object_graph(
...     binding_specs=[SomeBindingSpec()],
...     id_to_scope={'my custom scope': my_scope})
>>> some_class_1 = obj_graph.provide(SomeClass)
>>> some_class_2 = obj_graph.provide(SomeClass)
>>> my_scope.clear()
>>> some_class_3 = obj_graph.provide(SomeClass)
>>> some_class_1.foo is some_class_2.foo
True
>>> some_class_2.foo is some_class_3.foo
False
>>>
}}}

A scope identifier can be any object implementing `__eq__()` and `__hash__()`.

If you plan to use Pinject in a multi-threaded environment (and even if you
don't plan to now but may some day), you should make your custom scope
thread-safe.  The example custom scope above could be trivially (but more
verbosely) rewritten to be thread-safe, as in the example below.  The lock is
reentrant so that something in `MyScope` can be injected into something else
in `MyScope`.

{{{
>>> class MyScope(pinject.Scope):
...     def __init__(self):
...         self._cache = {}
...         self._rlock = threading.RLock()
...     def provide(self, binding_key, default_provider_fn):
...         with self._rlock:
...             if binding_key not in self._cache:
...                 self._cache[binding_key] = default_provider_fn()
...             return self._cache[binding_key]
...     def clear(self):
...         with self._rlock:
...             self._cache = {}
>>>
}}}

== Scope accessibility ==

To prevent yourself from injecting objects where they don't belong, you may
want to validate one object being injected into another w.r.t. scope.

For instance, you may have created a custom scope for HTTP requests handled by
your program.  Objects in request scope would be cached for the duration of a
single HTTP request.  You may want to verify that objects in request scope
never get injected into objects in singleton scope.  Such an injection is
likely not to make semantic sense, since it would make something tied to one
HTTP request be used for the duration of your program.

Pinject lets you pass a validation function as the
`is_scope_usable_from_scope` arg to `new_object_graph()`.  This function takes
two scope identifiers and returns `True` iff an object in the first scope can
be injected into an object of the second scope.

{{{
>>> class RequestScope(pinject.Scope):
...     def start_request(self):
...         self._cache = {}
...     def provide(self, binding_key, default_provider_fn):
...         if binding_key not in self._cache:
...             self._cache[binding_key] = default_provider_fn()
...         return self._cache[binding_key]
...
>>> class SomeClass(object):
...     def __init__(self, foo):
...         self.foo = foo
...
>>> class SomeBindingSpec(pinject.BindingSpec)
...     @pinject.in_scope(pinject.SINGLETON)
...     def provide_foo(bar):
...         return 'foo-' + bar
...     @pinject.in_scope('request scope')
...     def provide_bar():
...         return '-bar'
...
>>> def is_usable(scope_id_inner, scope_id_outer):
...     return not (scope_id_inner == 'request scope' and
...                 scope_id_outer == scoping.SINGLETON)
...
>>> my_request_scope = RequestScope()
>>> obj_graph = pinject.new_object_graph(
...     binding_specs=[SomeBindingSpec()],
...     id_to_scope={'request scope': my_request_scope},
...     is_scope_usable_from_scope=is_usable)
>>> my_request_scope.start_request()
>>> # obj_graph.provide(SomeClass)  # would raise a BadDependencyScopeError
>>>
}}}

The default scope accessibility validator allows objects from any scope to be
injected into objects from any other scope.

== Gotchas ==

Pinject has a few things to watch out for.

=== Thread safety ===

Pinject's default scope is `SINGLETON`.  If you have a multi-threaded program,
it's likely that some or all of the things that Pinject provides from
singleton scope will be used in multiple threads.  So, it's important that you
ensure that such classes are thread-safe.

Similarly, it's important that your custom scope classes are thread-safe.
Even if the objects they provide are only used in a single thread, it may be
that the object graph (and therefore the scope itself) will be used
simultaneously in multiple threads.

Remember to make locks re-entrant on your custom scope classes, or otherwise
deal with one object in your custom scope trying to inject another object in
your custom scope.

That's it for gotchas, for now.
